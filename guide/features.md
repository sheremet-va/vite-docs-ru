# Возможности

На самом базовом уровне разработка с использованием Vite не сильно отличается от использования статического файлового сервера. Однако Vite предоставляет множество улучшений по сравнению с нативным  ESM импортом для поддержки различных функций, которые обычно встречаются в настройках на основе сборщика.

## Разрешение зависимостей NPM и предварительная сборка

Нативные ES импорты не поддерживает импорт пустых модулей, например:

```js
import { someMethod } from 'my-dep'
```

Вышеупомянутый код вызовет ошибку в браузере. Vite обнаружит такой простой импорт модуля во всех обслуживаемых исходных файлах и выполнит следующее:

1. [Предварительно соберет](./dep-pre-bundling) их, чтобы улучшить скорость загрузки страницы и преобразовать CommonJS / UMD модули в ESM. Этап предварительной сборки выполняется с помощью [esbuild](http://esbuild.github.io/) и делает время холодного запуска Vite значительно быстрее, чем у любого сборщика на основе JavaScript.

2. Перепишит импорты на допустимые URL-адреса, например `/node_modules/.vite/my-dep.js?v=f3sf2ebd`, чтобы браузер мог их правильно импортировать.

**Зависимости сильно кэшируются**

Vite кэширует запросы зависимостей через HTTP-заголовки, поэтому, если вы хотите локально редактировать/отлаживать зависимость, следуйте инструкциям [здесь](./dep-pre-bundling#browser-cache).

## Горячего замена модулей

Vite предоставляет [HMR API](./api-hmr) поверх нативного ESM. Фреймворки с возможностями HMR могут использовать API для предоставления мгновенных и точных обновлений без перезагрузки страницы или изменения состояния приложения. Vite предоставляет собственные интеграции HMR для [однофайловых Vue компонентов](https://github.com/vitejs/vite/tree/main/packages/plugin-vue) и [React Fast Refresh](https://github.com/vitejs/vite/tree/main/packages/plugin-react-refresh). Также существует официальная интеграция для Preact через [@prefresh/vite](https://github.com/JoviDeCroock/prefresh/tree/main/packages/vite).

Обратите внимание, что вам не нужно настраивать их вручную - когда вы [создаете приложение с помощью `@vitejs/create-app`](./), в выбранных шаблонах они уже будут предварительно настроены для вас.

## TypeScript

Vite поддерживает импорт `.ts` файлов из коробки.

Vite выполняет транспиляцию только для `.ts` файлов и **НЕ** выполняет проверку типов. Предполагается, что проверка типов выполняется вашей IDE и процессом сборки (вы можете запустить `tsc --noEmit` в сценарии сборки или установить `vue-tsc` и запустить `vue-tsc --noEmit`, чтобы также проверить типы ваших `* .vue` файлов).

Vite использует [esbuild](https://github.com/evanw/esbuild) для транспиляции TypeScript в JavaScript, который примерно в 20~30 раз быстрее, чем `tsc`, а обновления HMR могут отображаться в браузере менее чем за 50 мс.

Обратите внимание: поскольку `esbuild` выполняет только транспиляцию без информации о типе, он не поддерживает определенные функции, такие как константное перечисление и неявный импорт только типа. Вы должны установить `"isolatedModules": true` в своем `tsconfig.json` в параметрах `compilerOptions`, чтобы TS предупреждал вас о функциях, которые не работают с изолированной транспиляцией.

### Типы клиентов

Дефолтные типы Vite предназначены для его Node.js API. Чтобы прокинуть окружение клиентского кода в приложение Vite, добавьте файл декларации `d.ts`:

```typescript
/// <reference types="vite/client" />
```

Также вы можете добавить `vite/client` в `compilerOptions.types` вашего `tsconfig`:

```json
{
  "compilerOptions": {
    "types": ["vite/client"]
  }
}
```

Это обеспечит следующее:

- Импорт ресурсов (например, импорт `.svg` файла)
- Типы для Vite-injected [env переменных](./env-and-mode#env-variables) в `import.meta.env`
- Типы для [HMR API](./api-hmr) в `import.meta.hot`

## Vue

Vite обеспечивает первоклассную поддержку Vue:

- Поддержка Vue 3 SFC через [@vitejs/plugin-vue](https://github.com/vitejs/vite/tree/main/packages/plugin-vue)
- Поддержка Vue 3 JSX через [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite/tree/main/packages/plugin-vue-jsx)
- Поддержка Vue 2 через [underfin/vite-plugin-vue2](https://github.com/underfin/vite-plugin-vue2)

## JSX

Файлы `.jsx` и `.tsx` также поддерживаются из коробки. Транспиляция JSX также выполняется через [esbuild](https://esbuild.github.io), и по умолчанию используется React 16. Поддержка JSX React 17 в esbuild отслеживается [здесь](https://github.com/evanw/esbuild/issues/334).

Пользователи Vue должны использовать официальный плагин [@vitejs/plugin-vue-jsx](https://github.com/vitejs/vite/tree/main/packages/plugin-vue-jsx), который предоставляет специальные функции Vue 3, включая HMR, глобальное разрешение компонентов, директивы и слоты.

Если JSX не используется с React или Vue, кастомные `jsxFactory` и` jsxFragment` могут быть настроены с помощью [`esbuild` опции](/config/#esbuild). Например, для Preact:

```js
// vite.config.js
export default {
  esbuild: {
    jsxFactory: 'h',
    jsxFragment: 'Fragment'
  }
}
```

Подробнее см. [документацию esbuild](https://esbuild.github.io/content-types/#jsx).

Вы можете внедрить JSX хелперы с помощью `jsxInject` (который доступен только для Vite), чтобы избежать ручного импорта:

```js
// vite.config.js
export default {
  esbuild: {
    jsxInject: `import React from 'react'`
  }
}
```

## CSS

При импорте `.css` файлов их содержимое будет вставлено на страницу с помощью тега `<style>` с поддержкой HMR. Вы также можете получить обработанный CSS в виде строки в качестве экспорта модуля по умолчанию.

### `@import` встраивание и перебазирование

Vite предварительно настроен для поддержки встраивания CSS `@import` через `postcss-import`. Алиасы Vite также поддерживаются для CSS `@import`. Кроме того, все CSS `url()` ссылки всегда автоматически перебазируются для обеспечения корректности, даже если импортированные файлы находятся в разных каталогах.

Алиасы `@import` и перебазирование URL-адресов также поддерживаются для Sass и Less файлов (см. [CSS препроцессоры](#css-pre-processors)).

### PostCSS

Если проект содержит валидную конфигурацию PostCSS (любой формат, поддерживаемый [postcss-load-config](https://github.com/postcss/postcss-load-config), например, `postcss.config.js`), он будет автоматически применяется ко всем импортированным CSS.

### CSS модули

Любой CSS файл, заканчивающийся на `.module.css`, считается [файлом CSS модулей](https://github.com/css-modules/css-modules). Импорт такого файла вернет соответствующий объект модуля:

```css
/* example.module.css */
.red {
  color: red;
}
```

```js
import classes from './example.module.css'
document.getElementById('foo').className = classes.red
```

Поведение CSS-модулей можно настроить с помощью [опции `css.modules`](/config/#css-modules).

Если для параметра `css.modules.localsConvention` установлено включение локальных переменных camelCase (например, `localsConvention: 'camelCaseOnly'`), вы также можете использовать именованный импорт:

```js
// .apply-color -> applyColor
import { applyColor } from './example.module.css'
document.getElementById('foo').className = applyColor
```

### CSS препроцессоры

Поскольку Vite нацелен только на современные браузеры, рекомендуется использовать нативные CSS переменные с плагинами PostCSS, которые реализуют CSSWG черновики (например, [postcss-nesting](https://github.com/jonathantneal/postcss-nesting)) и простые, будущие CSS стандарты.

Тем не менее, Vite обеспечивает встроенную поддержку `.scss`, `.sass`, `.less`, `.styl` and `.stylus` файлов. Для них нет необходимости устанавливать специальные плагины для Vite, но должен быть установлен сам соответствующий препроцессор:

```bash
# .scss и .sass
npm install -D sass

# .less
npm install -D less

# .styl и .stylus
npm install -D stylus
```

При использовании однофайловых Vue компонентов это также автоматически включает `<style lang="sass">` и др.

Vite улучшает резолв `@import` для Sass и Less, так что алиасы Vite также учитываются. Кроме того, относительные `url()` ссылки внутри импортированных Sass/Less файлов, которые находятся в каталогах, отличных от корневого файла, также автоматически перебазируются для обеспечения корректности.

Алиас `@import` и изменение URL-адреса не поддерживаются для Stylus из-за ограничений его API.

Вы также можете использовать CSS модули в сочетании с препроцессорами, добавив к расширению файла `.module`, например, `style.module.scss`.

## Статические ресурсы

Импорт статического ресурса вернет зарезолвленный публичный URL-адрес до места его хранения:

```js
import imgUrl from './img.png'
document.getElementById('hero-img').src = imgUrl
```

Специальные запросы могут изменять способ загрузки ресурсов:

```js
// Явная загрузка ресурса в виде URL
import assetAsURL from './asset.js?url'
```

```js
// Загрузка ресурса в виде строки
import assetAsString from './shader.glsl?raw'
```

```js
// Загрузка веб-воркера
import Worker from './worker.js?worker'
```

```js
// Веб-воркер встроится как base64 строка во время сборки
import InlineWorker from './worker.js?worker&inline'
```

Подробнее см. [Обработка статических ресурсов](./assets).

## JSON

JSON файлы можно импортировать напрямую - также поддерживается именованный импорт:

```js
// импортируем весь объект
import json from './example.json'
// импортируем корневое поле в качестве именованного экспорта - помогает с treeshaking!
import { field } from './example.json'
```

## Glob импорты

Vite поддерживает импорт нескольких модулей из файловой системы с помощью специальной функции `import.meta.glob`:

```js
const modules = import.meta.glob('./dir/*.js')
```

Код выше преобразуется в следующее:

```js
// код, созданный vite
const modules = {
  './dir/foo.js': () => import('./dir/foo.js'),
  './dir/bar.js': () => import('./dir/bar.js')
}
```

Затем вы можете перебрать ключи объекта `modules` для доступа к соответствующим модулям:

```js
for (const path in modules) {
  modules[path]().then((mod) => {
    console.log(path, mod)
  })
}
```

Соответствующие файлы по умолчанию лениво загружаются с помощью динамического импорта и будут разбиты на отдельные фрагменты во время сборки. Если вы предпочитаете импортировать все модули напрямую (например, полагаясь на побочные эффекты в этих модулях, которые будут применены первыми), вы можете вместо этого использовать `import.meta.globEager`:

```js
const modules = import.meta.globEager('./dir/*.js')
```

Код выше преобразуется в следующее:

```js
// код, созданный vite
import * as __glob__0_0 from './dir/foo.js'
import * as __glob__0_1 from './dir/bar.js'
const modules = {
  './dir/foo.js': __glob__0_0,
  './dir/bar.js': __glob__0_1
}
```

Обратите внимание, что:

- Это функция только для Vite и не является веб-стандартом или стандартом ES.
- glob паттерны обрабатываются как спецификаторы импорта: они должны быть относительными (начинаться с `. /`) или абсолютными (начинаться с `/`, относительно корня проекта).
- Сопоставление glob выполняется с помощью `fast-glob` - ознакомьтесь с его документацией для [поддерживаемых glob паттернов](https://github.com/mrmlnc/fast-glob#pattern-syntax).

## Web Assembly

Предварительно скомпилированные `.wasm` файлы можно импортировать напрямую - экспорт по умолчанию будет функцией инициализации, которая возвращает промис объекта экспорта wasm экземпляра:

```js
import init from './example.wasm'

init().then((exports) => {
  exports.test()
})
```

Функция init также может принимать объект `import`, который передается в `WebAssembly.instantiate` в качестве второго аргумента:

```js
init({
  imports: {
    someFunc: () => {
      /* ... */
    }
  }
}).then(() => {
  /* ... */
})
```

В production сборке `.wasm` файлы меньше, чем `assetInlineLimit`, будут встроены как base64 строки. В противном случае они будут скопированы в каталог dist как ресурс и будут отданы по запросу.

## Web Workers

Веб-воркер скрипты можно напрямую импортировать, добавив к запросу на импорт `?worker` или `?sharedworker`. По умолчанию экспортируется кастомный конструктор воркера:

```js
import MyWorker from './worker?worker'

const worker = new MyWorker()
```

Скрипт воркера также может использовать операторы `import` вместо `importScripts()` - обратите внимание, что во время разработки это зависит от встроенной поддержки браузера и в настоящее время работает только в Chrome, но для production сборки он компилируется.

По умолчанию скрипт воркера будет вставлен как отдельный чанк в production сборке. Если вы хотите встроить воркер как base64 строку, добавьте запрос `inline`:

```js
import MyWorker from './worker?worker&inline'
```

## Оптимизация сборки

> Перечисленные ниже функции автоматически применяются как часть процесса сборки, и нет необходимости в их явной настройке, только если вы не хотите их отключить.

### Разделение CSS кода

Vite автоматически извлекает CSS, используемый модулями, в асинхронный чанк и генерирует для него отдельный файл. CSS файл автоматически загружается через тег `<link>` при загрузке связанного асинхронного чанка, и асинхронный чанк гарантированно оценивается только после загрузки CSS, чтобы избежать [FOUC](https://en.wikipedia.org/wiki/Flash_of_unstyled_content#:~:text=A%20flash%20of%20unstyled%20content,before%20all%20information%20is%20retrieved.).

Если вы хотите, чтобы весь CSS был извлечен в один файл, вы можете отключить разделение CSS кода, установив для [`build.cssCodeSplit`](/config/#build-csscodesplit) значение` false`.

### Генерация preload директив

Vite автоматически генерирует директивы `<link rel="modulepreload">` для чанков и их прямого импорта в HTML.

### Оптимизация загрузки асинхронных чанков

В реальных приложениях Rollup часто генерирует "общие" чанки - код, который используется совместно двумя или более другими чанками. В сочетании с динамическим импортом довольно часто встречается следующий сценарий:

![graph](/images/graph.png)

В неоптимизированных сценариях, когда асинхронный чанк `A` импортируется, браузер должен будет запросить и проанализировать `A`, прежде чем он сможет определить, что ему также нужен общий чанк `C`. Это приводит к дополнительному сетевому обходу:

```
Entry ---> A ---> C
```

Vite автоматически перезаписывает вызовы динамического импорта с разделением кода с шагом предварительной загрузки, так что, когда запрашивается `A`, то ` C` извлекается **параллельно**:

```
Entry ---> (A + C)
```

Возможно, что `C` будет иметь дальнейший импорт, что приведет к еще большему количеству обходов в неоптимизированном сценарии. Оптимизация Vite будет отслеживать весь прямой импорт, чтобы полностью исключить обходы независимо от глубины импорта.